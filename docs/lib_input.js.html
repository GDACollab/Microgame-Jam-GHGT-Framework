<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/input.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/input.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import GlobalGameLoader from "../gameloader.js";

/** 
 * Input module, for detecting global keyboard and controller input.
 * @module input
*/

/**
 * Controls keyboard and controller support for interacting with menus and games. Will disable some inputs from going through unless it recognizes them.
 *
 * @class MicrogameInput
 */
class MicrogameInput {
    /**
     * A map of maps.
     * The bindings to use for each game (or all of them).
     * @todo FIX to be a map for all games.
     * @static
     */
    static bindings = new Map([["all", new Map([["w", "ArrowUp"], ["s", "ArrowDown"], ["a", "ArrowLeft"], ["d", "ArrowRight"]])]]);
    /**
     * Bindings to allow input for no matter what.
     * @static
     */
    static baseBindings = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", " "];
    
    /** 
     * What keys/controls are currently being used. Used in {@link module:input~MicrogameInput#update} exclusively.
    */
    #stateTracker = new Map();
    /** 
     * The current set of bindings we’re using from this.bindings. Set in {@link module:input~MicrogameInput#gameInputStartUpdate} based on the current game being played.
    */
    #currBinding;
    constructor() {
        this.#currBinding = this.constructor.bindings.get("all");
        this.#currBinding.forEach((keyToPress, binding) => {
            this.#stateTracker.set(binding, {key: keyToPress, isDown: false});
        }, this);
    }

    /**
     * Called by MicrogameInputManager. Updates {@link module:input~MicrogameInput#stateTracker} based on inputs it detects.
     * @returns The keys that we're going to be pressing based on our recieved inputs.
     */
    update() {
        var keysToPress = [];
        
        // We also want to include the "all" inputs:
        this.constructor.bindings.get("all").forEach((keyToPress, binding) => {
            if (!this.#stateTracker.has(binding)) {
                this.#stateTracker.set(binding, {key: keyToPress, isDown: false, binding: binding});
            }
            var pastState = this.#stateTracker.get(binding);
            var currState = this.getInput(binding);
            if (pastState.isDown !== currState) {
                var updatedState = {key: keyToPress, isDown: currState, binding: binding};
                keysToPress.push(updatedState);
                this.#stateTracker.set(binding, updatedState);
            }
        }, this);

        this.#currBinding.forEach((keyToPress, binding) => {
            if (!this.#stateTracker.has(binding)) {
                this.#stateTracker.set(binding, {key: keyToPress, isDown: false, binding: binding});
            }
            var pastState = this.#stateTracker.get(binding);
            var currState = this.getInput(binding);
            // We prioritize the current binding's keybinds:
            if (pastState.key !== keyToPress) {
                var update = keysToPress.findIndex(key => key.binding === binding);
                if (update !== undefined) {
                    keysToPress.splice(update, 1);
                }
            }
            if (pastState.isDown !== currState) {
                var updatedState = {key: keyToPress, isDown: currState};
                keysToPress.push(updatedState);
                this.#stateTracker.set(binding, updatedState);
            }
        }, this);
        return keysToPress;
    }


    /**
     * Resets {@link module:input~MicrogameInput#stateTracker} and {@link module:input~MicrogameInput#currBinding} based on game. If the game’s bindings exist in MicrogameInput.baseBindings, use those. Otherwise, use “all”.
     * @param {string} game Current game being played.
     */
    gameStartInputUpdate(game) {
        if (this.constructor.bindings.has(game)){
            this.#currBinding = this.constructor.bindings.get(game);
        } else {
            this.#currBinding = this.constructor.bindings.get("all");
        }
        this.#stateTracker = new Map();
        this.#currBinding.forEach((keyToPress, binding) => {
            this.#stateTracker.set(binding, {key: keyToPress, isDown: false});
        }, this);
    }
}

/**
 * Keyboard bindings.
 * Because the Keyboard API is still experimental, we're just going to use standard oninput stuff.
 * @class MicrogameKeyboard
 * @extends module:input~MicrogameInput
 */
class MicrogameKeyboard extends MicrogameInput {

    /** 
     * Set of keys that are currently being pressed. Accessed through {@link module:input~MicrogameKeyboard#getAnyInput} and {@link module:input~MicrogameKeyboard#getInput}.
    */
    #keysToDown = new Set();
    /**
     *
     * Set of keys used across all MicrogameKeyboards to list all keys currently being pressed.
     * Set in {@link module:input~MicrogameKeyboard#interruptInputUp} and {@link module:input~MicrogameKeyboard#interruptInputDown}.
     * Used only in {@link module:optionsmanager}.
     * @static
     */
    static allKeysDown = new Set();

    /**
     * The HREF of the current game loaded. Used to ignore key presses if a keyboard event is targeting the gameLocation.
     * @private
     */
    #gameLocation;

    constructor() {
        super();
        window.addEventListener("keydown", this.#interruptInputDown.bind(this), {capture: true});
        document.getElementById("game").contentWindow.addEventListener("keydown", this.#interruptInputDown.bind(this), {capture: true});
        window.addEventListener("keyup", this.#interruptInputUp.bind(this), {capture: true});
        document.getElementById("game").contentWindow.addEventListener("keyup", this.#interruptInputUp.bind(this), {capture: true});
    }

    /**
     * When any key is pressed, check to see if it’s a {@link module:input~MicrogameKeyboard#baseBindings|baseBinding} (i.e., an allowed keyboard press). If so, press it. If not, add it to the list of keys to be queried for input ({@link module:input~MicrogameKeyboard#keysToDown}).
     * @private
     * @alias module:input~MicrogameKeyboard#interruptInputDown
     * @todo Fix to work so that you can send keys in place of the standard arrows.
     */
    #interruptInputDown(ev) {
        MicrogameKeyboard.allKeysDown.add(ev.key);
        if (this.constructor.baseBindings.includes(ev.key)) {
            if (GlobalGameLoader.inGame &amp;&amp; !(("location" in ev.target &amp;&amp; ev.target.location.href === this.#gameLocation) || (("baseURI" in ev.target) &amp;&amp; ev.target.baseURI === this.#gameLocation))) {
                // For Unity games, we have to pass keyboard controls directly to the game in the iframe:
                MicrogameInputManager.pressKey(ev.key, "down");
            }
            return;
        } else {
            this.#keysToDown.add(ev.key);
            ev.preventDefault();
        }
    }

    /**
     * {@link module:input~MicrogameKeyboard#interruptInputDown}, but for when keys are released. And so delete from {@link module:input~MicrogameKeyboard#keysToDown}.
     * @alias module:input~MicrogameKeyboard#interruptInputUp
     */
    #interruptInputUp(ev) {
        MicrogameKeyboard.allKeysDown.delete(ev.key);
        if (this.constructor.baseBindings.includes(ev.key)) {
            if (GlobalGameLoader.inGame &amp;&amp; !(("location" in ev.target &amp;&amp; ev.target.location.href === this.#gameLocation) || (("baseURI" in ev.target) &amp;&amp; ev.target.baseURI === this.#gameLocation))) {
                // For Unity games, we have to pass keyboard controls directly to the game in the iframe:
                MicrogameInputManager.pressKey(ev.key, "up");
            }
            return;
        } else {
            this.#keysToDown.delete(ev.key);
            ev.preventDefault();
        }
    }

    /**
     * @returns {object} {control: key, type: MicrogameKeyboard} being pressed if it detects any input. null otherwise.
     */
    getAnyInput() {
        var iter = this.#keysToDown.values().next();
        if (!iter.done) {
            return {control: iter.value, type: MicrogameKeyboard};
        }
        return null;
    }

    /**
     * 
     * @param {string} control The key code that we’re checking for
     * @returns {boolean} Is the key code that we’re checking for being pressed?
     */
    getInput(control) {
        return this.#keysToDown.has(control);
    }

    /**
     * Called whenever a game starts. Resets the {@link module:input~MicrogameKeyboard#interruptInput} Down and Up bindings. Also sets {@link module:input~MicrogameKeyboard#gameLocation}.
     * @param {string} game {@link module:gameloader~GameLoader#game}
     */
    gameStartInputUpdate(game) {
        super.gameStartInputUpdate(game);
        document.getElementById("game").contentWindow.addEventListener("keydown", this.#interruptInputDown.bind(this), {capture: true});
        document.getElementById("game").contentWindow.addEventListener("keyup", this.#interruptInputUp.bind(this), {capture: true});
        this.#gameLocation = document.getElementById("game").contentWindow.location.href;
    }
}

class MicrogameGamepad extends MicrogameInput {
    #gamepad;
    #sensitivity = 0.4;
    static bindings = new Map([
        ["all", new Map([["-axes1", "ArrowUp"],
        ["axes1", "ArrowDown"],
        ["-axes0", "ArrowLeft"],
        ["axes0", "ArrowRight"],
        ["buttons0", " "]])]
    ]);

    constructor(gamepad) {
        super();
        this.#gamepad = gamepad;
    }

    #inputMatch = /(-)?(axes|buttons)(\d)+/;

    getInput(control) {
        if (typeof control === "string"){
            var inputVal = this.#inputMatch.exec(control);
            if (inputVal !== null) {
                var val = this.#gamepad[inputVal[2]][inputVal[3]];
                if (val instanceof GamepadButton){
                    val = val.value;
                }
                return ((inputVal[1] === "-") ? -1 : 1) * val >= this.#sensitivity;
            } else {
                return false;
            }
        }
    }

    getAnyInput() {
        this.#gamepad.axes.forEach((axis, index) => {
            if (this.getInput("axes" + index)) {
                return { control: "axes" + index, type: MicrogameGamepad};
            } else if (this.getInput("-axes" + index)) {
                return {control: "-axes" + index, type: MicrogameGamepad};
            }
        }, this);
        this.#gamepad.buttons.forEach((button, index) => {
            if (this.getInput("buttons" + index)) {
                return {control: "buttons" + index, type: MicrogameGamepad};
            }
        }, this);
        return null;
    }
}

class MicrogameInputManager {
    #defaultBindingStrings = {};
    #defaultBindingStringsByBindingName = {};
    #defaultBindings;
    
    #keysDown = new Set();
    #microgameInputs = { "keyboard": new MicrogameKeyboard()};

    constructor() {
        this.#defaultBindings = this.getAllBindings("all");
        this.#defaultBindingStrings = this.getBindingsStrings("all");
        this.#defaultBindingStringsByBindingName = this.getBindingsStringsByBindingName("all");
    }

    get defaultBindingStrings() {
        return this.#defaultBindingStrings;
    }

    setBindingFromOption(game, direction, option) {
        option.forEach((bindingObj, bindingName) => {
            var type = bindingObj.type;
            if (type === "MicrogameKeyboard") {
                type = MicrogameKeyboard;
            } else if (type === "MicrogameGamepad") {
                type = MicrogameGamepad;
            }
            var map = type.bindings;
            if (!map.has(game)){
                map.set(game, bindingObj.type.bindings.get("all"));
            }
            map.get(game).set(bindingName, direction);
        });
    }

    hasAdjustedBindings(game) {
        return MicrogameKeyboard.bindings.has(game) || MicrogameGamepad.bindings.has(game);
    }

    getAllBindings(game) {
        var bindings = {};

        MicrogameKeyboard.bindings.get(game).forEach((keyToPress, binding) => {
            var bindingObj = {control: binding, type: MicrogameKeyboard};
            if (keyToPress in bindings) {
                bindings[keyToPress].set(binding, bindingObj);
            } else {
                bindings[keyToPress] = new Map([[binding, bindingObj]]);
            }
        });
        MicrogameGamepad.bindings.get(game).forEach((keyToPress, binding) => {
            var bindingObj = {control: binding, type: MicrogameGamepad};
            if (keyToPress in bindings) {
                bindings[keyToPress].set(binding, bindingObj);
            } else {
                bindings[keyToPress] = new Map([[binding, bindingObj]]);
            }
        });
        return bindings;
    }

    addBinding(game, bindingName, binding){
        var map = binding.type.bindings;
        if (!map.has(game)) {
            MicrogameGamepad.bindings.set(game, MicrogameGamepad.bindings.get("all"));
            MicrogameKeyboard.bindings.set(game, MicrogameKeyboard.bindings.get("all"));
        }
        
        map.get(game).set(binding.control, bindingName);
    }

    hasBinding(game, binding) {
        var map = binding.type.bindings;
        if (!map.has(game)) {
            return false;
        }
        return {has: map.get(game).has(binding.control), bindingName: map.get(game).get(binding.control)};
    } 

    clearBindings(game, bindingName) {
        if (!this.hasAdjustedBindings(game)) {
            MicrogameGamepad.bindings.set(game, MicrogameGamepad.bindings.get("all"));
            MicrogameKeyboard.bindings.set(game, MicrogameKeyboard.bindings.get("all"));
        }

        MicrogameGamepad.bindings.get(game).forEach((keyToPress, binding) => {
            if (keyToPress === bindingName) {
                MicrogameGamepad.bindings.get(game).delete(binding);
            }
        });
        MicrogameKeyboard.bindings.get(game).forEach((keyToPress, binding) => {
            if (keyToPress === bindingName) {
                MicrogameKeyboard.bindings.get(game).delete(binding);
            }
        });
    }

    resetBindings(game, bindingName) {
        this.#defaultBindings[bindingName].forEach((bindingObj, binding) => {
            bindingObj.type.bindings.get(game).set(binding, bindingName);
        });
    }

    getBindingsStrings(game) {
        if (!this.hasAdjustedBindings(game)) {
            return this.#defaultBindingStrings;
        }
        var s = {};
        MicrogameKeyboard.bindings.get(game).forEach((dir, binding) => {
            var dirStringName = dir.replace("Arrow", "").toLowerCase();
            if (dir === " ") {
                dirStringName = "space";
            }
            var stringToAdd = binding;
            if (stringToAdd === " ") {
                stringToAdd = "Space";
            }
            if (dirStringName in s) {
                s[dirStringName] += "," + stringToAdd;
            } else {
                s[dirStringName] = stringToAdd;
            }
        });

        MicrogameGamepad.bindings.get(game).forEach((dir, binding) => {
            var dirStringName = dir.replace("Arrow", "").toLowerCase();
            if (dir === " ") {
                dirStringName = "space";
            }
            if (dirStringName in s) {
                s[dirStringName] += "," + binding;
            } else {
                s[dirStringName] = binding;
            }
        });
        return s;
    }

    getBindingsStringsByBindingName(game) {
        if (!this.hasAdjustedBindings(game)) {
            return this.#defaultBindingStringsByBindingName;
        }
        var s = {};
        MicrogameKeyboard.bindings.get(game).forEach((dir, binding) => {
            var dirStringName = dir;
            var stringToAdd = binding;
            if (stringToAdd === " ") {
                stringToAdd = "Space";
            }
            if (dirStringName in s) {
                s[dirStringName] += "," + stringToAdd;
            } else {
                s[dirStringName] = stringToAdd;
            }
        });

        MicrogameGamepad.bindings.get(game).forEach((dir, binding) => {
            var dirStringName = dir;
            if (dirStringName in s) {
                s[dirStringName] += "," + binding;
            } else {
                s[dirStringName] = binding;
            }
        });
        return s;
    }

    getAnyInput() {
        for (var input in this.#microgameInputs) {
            var any = this.#microgameInputs[input].getAnyInput();
            if (any !== null) {
                return any;
            }
        }
        return null;
    }

    #captureNextCallback = null;
    captureNextInput(callback) {
        this.#captureNextCallback = callback;
    }
    cancelCaptureInput() {
        this.#captureNextCallback = null;
    }

    static gameTarget = null;
    static pressKey(key, isDown) {
        if (GlobalGameLoader.inGame) {
            var keyCodeConvert = {
                "ArrowLeft": 37,
                "ArrowRight": 39,
                "ArrowUp": 38,
                "ArrowDown": 40,
                " ": 32
            };
            MicrogameInputManager.gameTarget.dispatchEvent(new KeyboardEvent(`key${isDown}`, {
                key: key,
                charCode: 0,
                code: (key === " ") ? "Space" : key,
                // It's no surprise that Untiy WebGL is completely archaic and requires key codes to function properly:
                keyCode: keyCodeConvert[key],
                // Construct 3 is just like Unity in that it uses a deprecated keyCode feature...
                // Except it uses an entirely different property that has the same value. Go figure.
                which: keyCodeConvert[key]
            }));
        } else {
            document.body.dispatchEvent(new KeyboardEvent(`key${isDown}`, {
                key: key,
                code: (key === " ") ? "Space" : key
            }));
        }
    }

    updateInput() {
        if (!!navigator.getGamepads) {
            for (var gamepad of navigator.getGamepads()) {
                if (gamepad === null) {
                    continue;
                }
                if (!(gamepad.id in this.#microgameInputs)) {
                    this.#microgameInputs[gamepad.id] = new MicrogameGamepad(gamepad);
                }
            }
        }
        if (this.#captureNextCallback !== null) {
            var any = this.getAnyInput();
            // If the callback accepts the input we give it.
            if (this.#captureNextCallback(any)) {
                this.#captureNextCallback = null;
            }
        } else {
            for (var input in this.#microgameInputs) {
                var keysToPress = this.#microgameInputs[input].update();
                keysToPress.forEach((keyObj) => {
                    var isDown = keyObj.isDown;
                    var key = keyObj.key;
                    if (isDown &amp;&amp; !this.#keysDown.has(key)) {
                        this.#keysDown.add(key);
                        MicrogameInputManager.pressKey(key, "down");
                    } else if (!isDown &amp;&amp; this.#keysDown.has(key)) {
                        this.#keysDown.delete(key);
                        MicrogameInputManager.pressKey(key, "up");
                    }
                });
            }
        }
    }

    gameStartInputUpdate(game) {
        for (var input in this.#microgameInputs) {
            this.#microgameInputs[input].gameStartInputUpdate(game);
        }
        
        MicrogameInputManager.gameTarget = document.getElementById("game").contentWindow;
        var potentialCanvas = MicrogameInputManager.gameTarget.document.querySelector("canvas");
        // Might want to fix this logic structure if it gets more complicated than this. I don't want a tree of if-elses.
        
        // Unity is absolutely picky with how it wants to recieve inputs (same with Construct 3). On the absolute converse, Godot wants us to send inputs to canvases. So Javascript? Meet cheap workaround.
        if (potentialCanvas !== null &amp;&amp; potentialCanvas.id !== "unity-canvas" &amp;&amp; !("C3_IsSupported" in MicrogameInputManager.gameTarget)) {
            MicrogameInputManager.gameTarget = potentialCanvas;
        } else {
            // Our Twine script is similarly (and unintentionally) finnicky:
            var potentialTwine = MicrogameInputManager.gameTarget.document.querySelector("tw-story");
            if (potentialTwine !== null) {
                MicrogameInputManager.gameTarget = MicrogameInputManager.gameTarget.document.body;
            }
        }
    }
}

var GlobalInputManager = new MicrogameInputManager();

export {GlobalInputManager as default, MicrogameKeyboard};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-gameloader.html">gameloader</a></li><li><a href="module-input.html">input</a></li></ul><h3>Classes</h3><ul><li><a href="MicrogameJam.html">MicrogameJam</a></li><li><a href="module-gameloader-GameLoader.html">GameLoader</a></li><li><a href="module-input-MicrogameInput.html">MicrogameInput</a></li><li><a href="module-input-MicrogameKeyboard.html">MicrogameKeyboard</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-adding-games.html">adding-games</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DEBUG_DIFFICULTY">DEBUG_DIFFICULTY</a></li><li><a href="global.html#DEBUG_TEST">DEBUG_TEST</a></li><li><a href="global.html#DEBUG_TRANSITION">DEBUG_TRANSITION</a></li><li><a href="global.html#DEBUG_TRANSITION_LIFE_LOST">DEBUG_TRANSITION_LIFE_LOST</a></li><li><a href="global.html#DEBUG_TRANSITION_LIVES">DEBUG_TRANSITION_LIVES</a></li><li><a href="global.html#DEBUG_TRANSITION_LOOP">DEBUG_TRANSITION_LOOP</a></li><li><a href="global.html#MAX_ALLOWED_TIMER">MAX_ALLOWED_TIMER</a></li><li><a href="global.html#MIN_ALLOWED_TIMER">MIN_ALLOWED_TIMER</a></li><li><a href="global.html#SCREEN_HEIGHT">SCREEN_HEIGHT</a></li><li><a href="global.html#SCREEN_WIDTH">SCREEN_WIDTH</a></li><li><a href="global.html#debugLoopTransition">debugLoopTransition</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon Oct 02 2023 17:04:40 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
